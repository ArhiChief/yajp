/* Generated by re2c 2.0.3 on Sun Feb 28 11:18:31 2021 */
/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*-  */
/*
 * parser.h
 * Copyright (C) 2020 Sergei Kosivchenko <arhichief@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 * THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <errno.h>
#include "lexer.h"
#include "lexer_misc.h"


#ifdef YAJP_TRACK_STREAM
#   define LEXER_DECLARE_COUNTERS(input) int column_num = (input)->column_num, line_num = (input)->line_num
#   define LEXER_INC_COUNTER_LINE do { column_num = 0; line_num++; } while(0)
#   define LEXER_INC_COUNTER_COLUMN(val) do { column_num += val;  } while(0)
#   define LEXER_STORE_COUNTERS(result) do { (result)->column_num = column_num; (result)->column_num = column_num; } while(0)
#else
#   define LEXER_DECLARE_COUNTERS(input) {}
#   define LEXER_INC_COUNTER_LINE do { } while(0)
#   define LEXER_INC_COUNTER_COLUMN(val) do { } while(0)
#   define LEXER_STORE_COUNTERS(result) do { } while(0)
#endif

int yajp_lexer_get_next_token(yajp_lexer_input_t *input, yajp_lexer_token_t *token) {
    #define YYMAXFILL 5


    int ret = 0;
    LEXER_DECLARE_COUNTERS(input);

    /*
     * Source code for scanner was taken from
     * https://fuchsia.googlesource.com/third_party/json/+/develop/src/json.hpp.re2c
     * and modified for yajp needs
     */

    errno = 0;

loop:
    input->token = input->cursor; // save start position of scanning token
    
{
	uint8_t picked_char;
	unsigned int yyaccept = 0;
	if ((input->limit - input->cursor) < 5) { if (0 != yajp_lexer_fill_input(input, 5)) { return -1; } }
	picked_char = *input->cursor;
	switch (picked_char) {
	case 0x00:	goto yy2;
	case '\t':
	case ' ':	goto yy6;
	case '\n':
	case '\r':	goto yy9;
	case '"':	goto yy12;
	case ',':	goto yy13;
	case '-':	goto yy15;
	case '0':	goto yy16;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy18;
	case ':':	goto yy20;
	case 'F':
	case 'f':	goto yy22;
	case 'N':
	case 'n':	goto yy23;
	case 'T':
	case 't':	goto yy24;
	case '[':	goto yy25;
	case ']':	goto yy27;
	case '{':	goto yy29;
	case '}':	goto yy31;
	case 0xEF:	goto yy33;
	default:	goto yy4;
	}
yy2:
	++input->cursor;
	{ ret = yajp_lexer_pick_token(YAJP_TOKEN_EOF, input, token); goto end; }
yy4:
	++input->cursor;
yy5:
	{ errno = EINVAL; LEXER_INC_COUNTER_COLUMN(1); ret = -1; goto end; }
yy6:
	++input->cursor;
	if (input->limit <= input->cursor) { if (0 != yajp_lexer_fill_input(input, 1)) { return -1; } }
	picked_char = *input->cursor;
	switch (picked_char) {
	case '\t':
	case ' ':	goto yy6;
	default:	goto yy8;
	}
yy8:
	{ LEXER_INC_COUNTER_COLUMN(1); goto loop; }
yy9:
	++input->cursor;
	if (input->limit <= input->cursor) { if (0 != yajp_lexer_fill_input(input, 1)) { return -1; } }
	picked_char = *input->cursor;
	switch (picked_char) {
	case '\n':
	case '\r':	goto yy9;
	default:	goto yy11;
	}
yy11:
	{ LEXER_INC_COUNTER_LINE; goto loop; }
yy12:
	yyaccept = 0;
	picked_char = *(input->marker = ++input->cursor);
	if (picked_char <= 0x1F) goto yy5;
	goto yy35;
yy13:
	++input->cursor;
	{ ret = yajp_lexer_pick_token(YAJP_TOKEN_COMMA, input, token); LEXER_INC_COUNTER_COLUMN(1); goto end; }
yy15:
	picked_char = *++input->cursor;
	switch (picked_char) {
	case '0':	goto yy16;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy18;
	default:	goto yy5;
	}
yy16:
	yyaccept = 1;
	picked_char = *(input->marker = ++input->cursor);
	switch (picked_char) {
	case '.':	goto yy40;
	case 'E':
	case 'e':	goto yy41;
	default:	goto yy17;
	}
yy17:
	{ ret = yajp_lexer_pick_token(YAJP_TOKEN_NUMBER, input, token); LEXER_INC_COUNTER_COLUMN((token->attributes.value_size) / sizeof(picked_char)); goto end; }
yy18:
	yyaccept = 1;
	input->marker = ++input->cursor;
	if ((input->limit - input->cursor) < 3) { if (0 != yajp_lexer_fill_input(input, 3)) { return -1; } }
	picked_char = *input->cursor;
	switch (picked_char) {
	case '.':	goto yy40;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy18;
	case 'E':
	case 'e':	goto yy41;
	default:	goto yy17;
	}
yy20:
	++input->cursor;
	{ ret = yajp_lexer_pick_token(YAJP_TOKEN_COLON, input, token); LEXER_INC_COUNTER_COLUMN(1); goto end; }
yy22:
	yyaccept = 0;
	picked_char = *(input->marker = ++input->cursor);
	switch (picked_char) {
	case 'A':
	case 'a':	goto yy42;
	default:	goto yy5;
	}
yy23:
	yyaccept = 0;
	picked_char = *(input->marker = ++input->cursor);
	switch (picked_char) {
	case 'U':
	case 'u':	goto yy43;
	default:	goto yy5;
	}
yy24:
	yyaccept = 0;
	picked_char = *(input->marker = ++input->cursor);
	switch (picked_char) {
	case 'R':
	case 'r':	goto yy44;
	default:	goto yy5;
	}
yy25:
	++input->cursor;
	{ ret = yajp_lexer_pick_token(YAJP_TOKEN_ABEGIN, input, token); LEXER_INC_COUNTER_COLUMN(1); goto end; }
yy27:
	++input->cursor;
	{ ret = yajp_lexer_pick_token(YAJP_TOKEN_AEND, input, token); LEXER_INC_COUNTER_COLUMN(1); goto end; }
yy29:
	++input->cursor;
	{ ret = yajp_lexer_pick_token(YAJP_TOKEN_OBEGIN, input, token); LEXER_INC_COUNTER_COLUMN(1); goto end; }
yy31:
	++input->cursor;
	{ ret = yajp_lexer_pick_token(YAJP_TOKEN_OEND, input, token); LEXER_INC_COUNTER_COLUMN(1); goto end; }
yy33:
	yyaccept = 0;
	picked_char = *(input->marker = ++input->cursor);
	switch (picked_char) {
	case 0xBB:	goto yy45;
	default:	goto yy5;
	}
yy34:
	++input->cursor;
	if (input->limit <= input->cursor) { if (0 != yajp_lexer_fill_input(input, 1)) { return -1; } }
	picked_char = *input->cursor;
yy35:
	switch (picked_char) {
	case 0x00:
	case 0x01:
	case 0x02:
	case 0x03:
	case 0x04:
	case 0x05:
	case 0x06:
	case 0x07:
	case 0x08:
	case '\t':
	case '\n':
	case '\v':
	case '\f':
	case '\r':
	case 0x0E:
	case 0x0F:
	case 0x10:
	case 0x11:
	case 0x12:
	case 0x13:
	case 0x14:
	case 0x15:
	case 0x16:
	case 0x17:
	case 0x18:
	case 0x19:
	case 0x1A:
	case 0x1B:
	case 0x1C:
	case 0x1D:
	case 0x1E:
	case 0x1F:	goto yy36;
	case '"':	goto yy37;
	case '\\':	goto yy39;
	default:	goto yy34;
	}
yy36:
	input->cursor = input->marker;
	if (yyaccept == 0) {
		goto yy5;
	} else {
		goto yy17;
	}
yy37:
	++input->cursor;
	{ ret = yajp_lexer_pick_token(YAJP_TOKEN_STRING, input, token); LEXER_INC_COUNTER_COLUMN((token->attributes.value_size + 2) / sizeof(picked_char)); goto end; }
yy39:
	++input->cursor;
	if (input->limit <= input->cursor) { if (0 != yajp_lexer_fill_input(input, 1)) { return -1; } }
	picked_char = *input->cursor;
	switch (picked_char) {
	case '"':
	case '/':
	case '\\':
	case 'b':
	case 'f':
	case 'n':
	case 'r':
	case 't':	goto yy34;
	case 'u':	goto yy46;
	default:	goto yy36;
	}
yy40:
	picked_char = *++input->cursor;
	switch (picked_char) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy47;
	default:	goto yy36;
	}
yy41:
	picked_char = *++input->cursor;
	switch (picked_char) {
	case '+':
	case '-':	goto yy49;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy50;
	default:	goto yy36;
	}
yy42:
	picked_char = *++input->cursor;
	switch (picked_char) {
	case 'L':
	case 'l':	goto yy52;
	default:	goto yy36;
	}
yy43:
	picked_char = *++input->cursor;
	switch (picked_char) {
	case 'L':
	case 'l':	goto yy53;
	default:	goto yy36;
	}
yy44:
	picked_char = *++input->cursor;
	switch (picked_char) {
	case 'U':
	case 'u':	goto yy54;
	default:	goto yy36;
	}
yy45:
	picked_char = *++input->cursor;
	switch (picked_char) {
	case 0xBF:	goto yy55;
	default:	goto yy36;
	}
yy46:
	++input->cursor;
	if (input->limit <= input->cursor) { if (0 != yajp_lexer_fill_input(input, 1)) { return -1; } }
	picked_char = *input->cursor;
	switch (picked_char) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':	goto yy57;
	default:	goto yy36;
	}
yy47:
	yyaccept = 1;
	input->marker = ++input->cursor;
	if ((input->limit - input->cursor) < 3) { if (0 != yajp_lexer_fill_input(input, 3)) { return -1; } }
	picked_char = *input->cursor;
	switch (picked_char) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy47;
	case 'E':
	case 'e':	goto yy41;
	default:	goto yy17;
	}
yy49:
	picked_char = *++input->cursor;
	switch (picked_char) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy50;
	default:	goto yy36;
	}
yy50:
	++input->cursor;
	if (input->limit <= input->cursor) { if (0 != yajp_lexer_fill_input(input, 1)) { return -1; } }
	picked_char = *input->cursor;
	switch (picked_char) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy50;
	default:	goto yy17;
	}
yy52:
	picked_char = *++input->cursor;
	switch (picked_char) {
	case 'S':
	case 's':	goto yy54;
	default:	goto yy36;
	}
yy53:
	picked_char = *++input->cursor;
	switch (picked_char) {
	case 'L':
	case 'l':	goto yy58;
	default:	goto yy36;
	}
yy54:
	picked_char = *++input->cursor;
	switch (picked_char) {
	case 'E':
	case 'e':	goto yy60;
	default:	goto yy36;
	}
yy55:
	++input->cursor;
	{ goto loop; }
yy57:
	++input->cursor;
	if (input->limit <= input->cursor) { if (0 != yajp_lexer_fill_input(input, 1)) { return -1; } }
	picked_char = *input->cursor;
	switch (picked_char) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':	goto yy62;
	default:	goto yy36;
	}
yy58:
	++input->cursor;
	{ ret = yajp_lexer_pick_token(YAJP_TOKEN_NULL, input, token); LEXER_INC_COUNTER_COLUMN(4); goto end; }
yy60:
	++input->cursor;
	{ ret = yajp_lexer_pick_token(YAJP_TOKEN_BOOLEAN, input, token); LEXER_INC_COUNTER_COLUMN((token->attributes.value_size) / sizeof(picked_char)); goto end; }
yy62:
	++input->cursor;
	if (input->limit <= input->cursor) { if (0 != yajp_lexer_fill_input(input, 1)) { return -1; } }
	picked_char = *input->cursor;
	switch (picked_char) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':	goto yy63;
	default:	goto yy36;
	}
yy63:
	++input->cursor;
	if (input->limit <= input->cursor) { if (0 != yajp_lexer_fill_input(input, 1)) { return -1; } }
	picked_char = *input->cursor;
	switch (picked_char) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':	goto yy34;
	default:	goto yy36;
	}
}


end:
    LEXER_STORE_COUNTERS(input);
    return ret;
}

#undef LEXER_DECLARE_COUNTERS
#undef LEXER_INC_COUNTER_LINE
#undef LEXER_INC_COUNTER_COLUMN
#undef LEXER_STORE_COUNTERS